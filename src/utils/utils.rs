use std::fs::File;
use std::io::{Result, Write};
use std::path::Path;
use std::sync::atomic::Ordering;
use crate::runner::{HAD_ERROR};
use crate::{RuntimeError, Token, Value};

// auto-generate types functions

fn main() -> Result<()> {
    let output_dir = "./generated";

    define_ast(
        output_dir,
        "Expr",
        vec![
            "Binary   : Box<Expr> left, Token operator, Box<Expr> right",
            "Grouping : Box<Expr> expression",
            "Literal  : LiteralValue value",
            "Unary    : Token operator, Box<Expr> right",
            "Variable : Token name",
        ],
    )?;

    define_ast(
        output_dir,
        "Stmt",
        vec![
            "Expression : Box<Expr> expression",
            "Print      : Box<Expr> expression",
            "Var        : Token name, Box<Expr> initializer",
        ],
    )?;

    Ok(())
}


pub fn define_ast(output_dir: &str, base_name: &str, types: Vec<&str>) -> Result<()> {
    let path = Path::new(output_dir).join(format!("{}.rs", base_name.to_lowercase()));
    let mut file = File::create(path)?;

    writeln!(file, "// This file is generated by generate_ast.rs")?;
    writeln!(file, "use crate::token::Token;")?;
    writeln!(file, "use crate::literal::LiteralValue;")?;
    writeln!(file, "")?;
    writeln!(file, "pub trait Visitor<R> {{")?;
    for type_def in &types {
        let class_name = type_def.split(':').next().unwrap().trim();
        writeln!(
            file,
            "    fn visit_{}_{}(&mut self, expr: &{}) -> R;",
            class_name.to_lowercase(),
            base_name.to_lowercase(),
            class_name
        )?;
    }
    writeln!(file, "}}\n")?;

    writeln!(file, "pub enum {} {{", base_name)?;
    for type_def in &types {
        let parts: Vec<&str> = type_def.split(':').collect();
        let class_name = parts[0].trim();
        let field_list = parts[1].trim();
        define_type(&mut file, class_name, field_list);
    }
    writeln!(file, "}}\n")?;

    writeln!(file, "impl {} {{", base_name)?;
    writeln!(
        file,
        "    pub fn accept<R>(&self, visitor: &mut dyn Visitor<R>) -> R {{"
    )?;
    writeln!(file, "        match self {{")?;
    for type_def in &types {
        let class_name = type_def.split(':').next().unwrap().trim();
        writeln!(
            file,
            "            {}::{} {{ .. }} => visitor.visit_{}_{}(self),",
            base_name,
            class_name,
            class_name.to_lowercase(),
            base_name.to_lowercase()
        )?;
    }
    writeln!(file, "        }}")?;
    writeln!(file, "    }}")?;
    writeln!(file, "}}")?;

    Ok(())
}

fn define_type(file: &mut File, class_name: &str, field_list: &str) {
    let fields: Vec<&str> = field_list.split(',').map(str::trim).collect();

    writeln!(file, "    {} {{", class_name).expect("TODO: panic message");
    for field in fields {
        let parts: Vec<&str> = field.split_whitespace().collect();
        let field_type = parts[0];
        let field_name = parts[1];
        writeln!(file, "        {}: {},", field_name, field_type).expect("TODO: panic message");
    }
    writeln!(file, "    }},").expect("TODO: panic message");
}

// printing functions

pub fn error(line: usize, message: &str) -> () {
    report(line, "", message);
}

pub fn report(line: usize, location: &str, message: &str) -> () {
    eprintln!("[line {} ] Error {} : {}", line, location, message);
    HAD_ERROR.store(true, Ordering::Relaxed);
}

pub fn runtime_error(err: RuntimeError) {
    match err {
        RuntimeError::Error { token, message } => {
            eprintln!("[line {}] RuntimeError at '{}': {}", token.line, token.lexeme, message);
        }
        RuntimeError::Return(_) => {
            // Do nothing â€“ returns are not actual runtime errors
        }
    }
}