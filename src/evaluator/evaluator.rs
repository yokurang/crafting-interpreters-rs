/*
An evaluator is a function that takes an AST as input and produces the result represented by the AST.
To achieve this, we need to define:
1. What values can be computed
2. Where, to store the values
In Lox, values are created by literals, computed by expressions, and stored in variables.
The user sees these as Lox objects, but they are implemented in the underlying language our interpreter is written in.
That means bridging the lands of Lox's dynamic typing and Java's static types. A variable in Lox can
store a value of any (Lox) type and can even store values of different types at different points in time.
*/

use crate::lexer::{Literal, TokenType};
use crate::parser::expr::{Expr, Visitor};
use crate::{Stmt, StmtVisitor, Token};
use std::fmt;
use std::fmt::Formatter;
/*
A literal is a bit of syntax that produces a value. Literals are the atomic bits that
compose a syntax. A literal comes from the parser's input. This is an important distinction,
as there can be values that are not generated by code from the source code. Furthermore,
it is important to distinguish between a literal, which is an input to the parser, and a value,
which is observed at runtime.
*/

pub struct Evaluator;

// representation of lox values at runtime
#[derive(Debug, Clone)]
pub enum Value {
    Number(f64),
    Bool(bool),
    String(String),
    Nil,
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Value::Number(n) => write!(f, "{}", n),
            Value::Bool(b) => write!(f, "{}", b),
            Value::String(s) => write!(f, "{}", s),
            Value::Nil => write!(f, "nil"),
        }
    }
}

impl Visitor for Evaluator {
    // Previously, the scanner scanned the source code and packed literal values into a token.
    // The parser then took the token and packed it into an AST node.
    // // Now, we take the AST expression and unpack its value.
    fn visit_literal_expr(&mut self, value: &Literal) -> Result<Value, RuntimeError> {
        match value {
            Literal::Number(n) => Ok(Value::Number(*n)),
            Literal::Bool(true) => Ok(Value::Bool(true)),
            Literal::Bool(false) => Ok(Value::Bool(false)),
            Literal::Nil => Ok(Value::Nil),
            Literal::String(s) => Ok(Value::String(s.clone())),
        }
    }

    // Since a grouping node has a reference to an expression inside parentheses,
    // to evaluate the grouping expression, we recursively evaluate the subexpression
    // and return it
    fn visit_grouping_expr(&mut self, expr: &Expr) -> Result<Value, RuntimeError> {
        self.evaluate(expr)
    }

    // first we evaluate the expression embedded in the unary expression,
    // then we apply the unary token on the expression we evaluated
    // finally we need a error handling mechanism to ensure that only unary
    // operators are valid
    // if we apply a minus, the subexpression has to be a number
    // we cast it before applying the operation, which happens at runtime
    // this is the essence of what makes the language dynamically typed
    // the recursion is post-order traversal, i.e we evaluate the children first before the current node
    // pre-order traversal works on the parent first then the child
    // in-order traversal: left child -> parent -> right child
    // depth order traversal: breadth-first search

    fn visit_unary_expr(&mut self, operator: &Token, right: &Expr) -> Result<Value, RuntimeError> {
        let right_val = self.evaluate(right)?;

        match operator.token_type {
            TokenType::Minus => {
                self.check_number_operand(operator.clone(), &right_val)?;
                if let Value::Number(n) = right_val {
                    Ok(Value::Number(-n))
                } else {
                    unreachable!() // this can't happen due to check_number_operand
                }
            }
            TokenType::Bang => Ok(Value::Bool(!self.is_truthy(&right_val))),
            _ => Err(RuntimeError::new(
                operator.clone(),
                "Unknown unary operator.".parse().unwrap(),
            )),
        }
    }

    fn visit_binary_expr(
        &mut self,
        left: &Expr,
        operator: &Token,
        right: &Expr,
    ) -> Result<Value, RuntimeError> {
        // a consequence of post-order traversal of AST is that we evaluate the left and right
        // subexpressions first before applying the operantor. As a conseuqence, if there is
        // an error and our sub-expressions have side effects, they will be produced first before
        // raising a runtime error
        let value_left: Value = self.evaluate(left)?;
        let value_right: Value = self.evaluate(right)?;
        match operator.token_type {
            TokenType::Minus => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        // note the subtly here that we evaluate from left-to-right.
                        // This means side effects will also be processed in left-to-right order
                        Value::Number(n2) => Ok(Value::Number(n1 - n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::Slash => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Number(n1 / n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::Star => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Number(n1 * n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::Plus => {
                // left to right traversal
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Number(n1 + n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    Value::String(s1) => match value_right {
                        Value::String(s2) => Ok(Value::String(format!("{}{}", s1, s2))),
                        _ => {
                            panic!("Right subexpression is not a string")
                        }
                    },
                    _ => Err(RuntimeError::new(
                        operator.clone(),
                        "Operands must be two numbers or string".parse().unwrap(),
                    )),
                }
            }
            TokenType::Greater => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Bool(n1 > n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::GreaterEqual => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Bool(n1 >= n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::Less => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Bool(n1 < n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::LessEqual => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Bool(n1 <= n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::BangEqual => Ok(Value::Bool(self.is_equal(&value_left, &value_right))),
            TokenType::EqualEqual => Ok(Value::Bool(self.is_equal(&value_left, &value_right))),
            _ => {
                panic!("Not a valid binary operator")
            }
        }
    }
}

/*
memory safe means that through a combination of static and runtime checking, a program can never
incorrectly interpret the data stored in bits of memory

static and syntax errors are both errors that are detected and caught before any code is evaluated.
runtime errors are code that raises an error during evaluation

For example, this expression is valid:
    2 * (3 / -"muffin")
And we should report the runtime error in the inner expression when that inner expression is being
evaluated. Moreover, when an error is encountered, we should halt the evaluation process
but not exit the entire program.

The tree-walk interpreter evaluates the AST using recursive calls.
*/

impl StmtVisitor<Result<(), RuntimeError>> for Evaluator {
    fn visit_expression_stmt(&mut self, stmt: &Stmt) -> Result<(), RuntimeError> {
        if let Stmt::Expression { expression } = stmt {
            let _ = self.evaluate(expression)?;
        }
        Ok(())
    }

    fn visit_print_stmt(&mut self, stmt: &Stmt) -> Result<(), RuntimeError> {
        if let Stmt::Print { expression } = stmt {
            match self.evaluate(expression) {
                Ok(value) => {
                    println!("{}", value);
                    Ok(())
                }
                Err(err) => Err(err),
            }
        } else {
            Ok(())
        }
    }
}

#[derive(Debug)]
pub struct RuntimeError {
    pub token: Token,
    pub message: String,
}

impl RuntimeError {
    pub fn new(token: Token, message: String) -> Self {
        Self { token, message }
    }
}

impl fmt::Display for RuntimeError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "[line {}] RuntimeError at '{}': {}",
            self.token.line, self.token.lexeme, self.message
        )
    }
}

impl std::error::Error for RuntimeError {}

impl Evaluator {
    pub fn new() -> Self {
        Self
    }

    pub fn evaluate(&mut self, expr: &Expr) -> Result<Value, RuntimeError> {
        expr.accept(self)
    }
    
    pub fn execute(&mut self, stmt: &Stmt) -> Result<(), RuntimeError> {
        stmt.accept(self)
    }

    pub fn check_number_operand(
        &self,
        operator: Token,
        operand: &Value,
    ) -> Result<(), RuntimeError> {
        // this mechanism keeps track of the token which causes the runtime error
        // so we can print the token and line that triggered the runtime error
        match operand {
            Value::Number(_) => Ok(()),
            _ => Err(RuntimeError::new(
                operator,
                "Operand must be a number".parse().unwrap(),
            )),
        }
    }

    pub fn check_number_operands(
        &self,
        operator: Token,
        left: &Value,
        right: &Value,
    ) -> Result<(), RuntimeError> {
        // this mechanism keeps track of the token which causes the runtime error
        // so we can print the token and line that triggered the runtime error
        match left {
            Value::Number(_) => match right {
                Value::Number(_) => Ok(()),
                _ => Err(RuntimeError::new(
                    operator,
                    "Right operand must be a number".parse().unwrap(),
                )),
            },
            _ => Err(RuntimeError::new(
                operator,
                "Left operand must be a number".parse().unwrap(),
            )),
        }
    }

    pub fn is_truthy(&self, value: &Value) -> bool {
        match value {
            Value::Nil => false,
            Value::Bool(b) => *b,
            _ => true,
        }
    }

    pub fn is_equal(&self, v1: &Value, v2: &Value) -> bool {
        match (v1, v2) {
            (Value::Nil, Value::Nil) => true,
            (Value::Bool(b1), Value::Bool(b2)) => b1 == b2,
            (Value::Number(n1), Value::Number(n2)) => n1 == n2,
            (Value::String(s1), Value::String(s2)) => s1 == s2,
            _ => false,
        }
    }
}
