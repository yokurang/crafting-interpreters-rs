/*
An evaluator is a function that takes an AST as input and produces the result represented by the AST.
To achieve this, we need to define:
1. What values can be computed
2. Where, to store the values
In Lox, values are created by literals, computed by expressions, and stored in variables.
The user sees these as Lox objects, but they are implemented in the underlying language our interpreter is written in.
That means bridging the lands of Lox's dynamic typing and Java's static types. A variable in Lox can
store a value of any (Lox) type and can even store values of different types at different points in time.
*/

use crate::lexer::{Literal, TokenType};
use crate::parser::expr::{Expr, Visitor};
use crate::{Environment, LoxFunction, Stmt, StmtVisitor, Token};
use std::fmt;
use std::fmt::Formatter;
use std::rc::Rc;
/*
A literal is a bit of syntax that produces a value. Literals are the atomic bits that
compose a syntax. A literal comes from the parser's input. This is an important distinction,
as there can be values that are not generated by code from the source code. Furthermore,
it is important to distinguish between a literal, which is an input to the parser, and a value,
which is observed at runtime.
*/

pub struct Evaluator {
    pub environment: Environment
}

// representation of lox values at runtime
#[derive(Debug, Clone)]
pub enum Value {
    Number(f64),
    Bool(bool),
    String(String),
    Nil,
    Callable(Rc<dyn LoxCallable>),
}

pub trait LoxCallable: std::fmt::Debug {
    fn arity(&self) -> usize;
    fn call(
        &self,
        interpreter: &mut Evaluator,
        arguments: Vec<Value>,
    ) -> Result<Value, RuntimeError>;
}

#[derive(Debug)]
pub struct ClockFn;

impl LoxCallable for ClockFn {
    fn arity(&self) -> usize { 0 }

    fn call(
        &self,
        _interpreter: &mut Evaluator,
        _arguments: Vec<Value>,
    ) -> Result<Value, RuntimeError> {
        use std::time::{SystemTime, UNIX_EPOCH};
        let secs = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs_f64();
        Ok(Value::Number(secs))
    }
}

impl fmt::Display for ClockFn {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "<native fn>")
    }
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Value::Number(n) => write!(f, "{}", n),
            Value::Bool(b) => write!(f, "{}", b),
            Value::String(s) => write!(f, "{}", s),
            Value::Nil => write!(f, "nil"),
            Value::Callable(_) => write!(f, "<fn>"),
        }
    }
}

impl Visitor for Evaluator {
    // Previously, the scanner scanned the source code and packed literal values into a token.
    // The parser then took the token and packed it into an AST node.
    // // Now, we take the AST expression and unpack its value.
    fn visit_literal_expr(&mut self, literal: &Literal) -> Result<Value, RuntimeError> {
        match literal {
            Literal::Number(n) => Ok(Value::Number(*n)),
            Literal::Bool(true) => Ok(Value::Bool(true)),
            Literal::Bool(false) => Ok(Value::Bool(false)),
            Literal::Nil => Ok(Value::Nil),
            Literal::String(s) => Ok(Value::String(s.clone())),
        }
    }

    // Since a grouping node has a reference to an expression inside parentheses,
    // to evaluate the grouping expression, we recursively evaluate the subexpression
    // and return it
    fn visit_grouping_expr(&mut self, expr: &Expr) -> Result<Value, RuntimeError> {
        self.evaluate(expr)
    }

    // first we evaluate the expression embedded in the unary expression,
    // then we apply the unary token on the expression we evaluated
    // finally we need an error handling mechanism to ensure that only unary
    // operators are valid
    // if we apply a minus, the subexpression has to be a number
    // we cast it before applying the operation, which happens at runtime
    // this is the essence of what makes the language dynamically typed
    // the recursion is post-order traversal, i,e. we evaluate the children first before the current node
    // pre-order traversal works on the parent first then the child
    // in-order traversal: left child -> parent -> right child
    // depth order traversal: breadth-first search

    fn visit_unary_expr(&mut self, operator: &Token, right: &Expr) -> Result<Value, RuntimeError> {
        let right_val = self.evaluate(right)?;

        match operator.token_type {
            TokenType::Minus => {
                self.check_number_operand(operator.clone(), &right_val)?;
                if let Value::Number(n) = right_val {
                    Ok(Value::Number(-n))
                } else {
                    unreachable!() // this can't happen due to check_number_operand
                }
            }
            TokenType::Bang => Ok(Value::Bool(!self.is_truthy(&right_val))),
            _ => Err(RuntimeError::new(
                operator.clone(),
                "Unknown unary operator.".parse().unwrap(),
            )),
        }
    }

    fn visit_binary_expr(
        &mut self,
        left: &Expr,
        operator: &Token,
        right: &Expr,
    ) -> Result<Value, RuntimeError> {
        // a consequence of post-order traversal of AST is that we evaluate the left and right
        // subexpressions first before applying the operator. As a consequence, if there is
        // an error and our sub-expressions have side effects, they will be produced first before
        // raising a runtime error
        let value_left: Value = self.evaluate(left)?;
        let value_right: Value = self.evaluate(right)?;
        match operator.token_type {
            TokenType::Minus => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        // note the subtly here that we evaluate from left-to-right.
                        // This means side effects will also be processed in left-to-right order
                        Value::Number(n2) => Ok(Value::Number(n1 - n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::Slash => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Number(n1 / n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::Star => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Number(n1 * n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::Plus => {
                // left to right traversal
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Number(n1 + n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    Value::String(s1) => match value_right {
                        Value::String(s2) => Ok(Value::String(format!("{}{}", s1, s2))),
                        _ => {
                            panic!("Right subexpression is not a string")
                        }
                    },
                    _ => Err(RuntimeError::new(
                        operator.clone(),
                        "Operands must be two numbers or string".parse().unwrap(),
                    )),
                }
            }
            TokenType::Greater => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Bool(n1 > n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::GreaterEqual => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Bool(n1 >= n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::Less => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Bool(n1 < n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::LessEqual => {
                self.check_number_operands(operator.clone(), &value_right, &value_left)?;
                match value_left {
                    Value::Number(n1) => match value_right {
                        Value::Number(n2) => Ok(Value::Bool(n1 <= n2)),
                        _ => {
                            panic!("Right subexpression is not a number")
                        }
                    },
                    _ => {
                        panic!("Left subexpression is not a number")
                    }
                }
            }
            TokenType::BangEqual => Ok(Value::Bool(self.is_equal(&value_left, &value_right))),
            TokenType::EqualEqual => Ok(Value::Bool(self.is_equal(&value_left, &value_right))),
            _ => {
                panic!("Not a valid binary operator")
            }
        }
    }

    fn visit_variable_expr(&mut self, token: &Token, _initializer: &Option<Box<Expr>>) -> Result<Value, RuntimeError> {
        self.environment.get(token)
    }

    fn visit_assign_expr(&mut self, token: &Token, value: &Expr) -> Result<Value, RuntimeError> {
        let value = self.evaluate(value)?;
        self.environment.assign(&token, value.clone())?;
        Ok(value)
    }

    fn visit_logical_expr(
        &mut self,
        left: &Expr,
        operator: &Token,
        right: &Expr,
    ) -> Result<Value, RuntimeError> {
        let left_val = self.evaluate(left)?;

        match operator.token_type {
            TokenType::Or => {
                // short-circuit when the left side is truthy
                if self.is_truthy(&left_val) {
                    return Ok(left_val);
                }
            }
            TokenType::And => {
                // short-circuit when the left side is falsy
                if !self.is_truthy(&left_val) {
                    return Ok(left_val);
                }
            }
            _ => {
                return Err(RuntimeError::new(
                    operator.clone(),
                    "Unknown logical operator.".to_string(),
                ))
            }
        }

        // need the right-hand side value
        self.evaluate(right)
    }

    fn visit_call_expr(&mut self, callee: &Expr, paren: &Token, arguments: &[Expr]) -> Result<Value, RuntimeError> {
        /*
        First, we evaluate the expression for the callee. Typically, this
        expression is just an identifier that looks up the expression by name, but it could
        be anything. We evaluate each of the argument expressions in order and store
        the resulting values in a list.
        */
        let callee_val = self.evaluate(callee)?;

        // 2. Evaluate each argument
        let mut arg_vals = Vec::with_capacity(arguments.len());
        for arg in arguments {
            arg_vals.push(self.evaluate(arg)?);
        }

        /* performing the call
        We do that by casting the callee to a LoxCallable and then
        invoking a `call()` method on it. The Java representation of any Lox
        object thay can be called like a function implement this interface.
        This includes user-defined functions and also class objects since classes are
        'called' to construct new instances. 
        */

        // 3. Check that the callee is actually callable
        match callee_val {
            Value::Callable(ref function) => {
                // 3a. Arity check (optional but nice to keep the bookâ€™s behaviour)
                if arg_vals.len() != function.arity() {
                    return Err(RuntimeError::new(
                        paren.clone(),
                        format!(
                            "Expected {} arguments but got {}.",
                            function.arity(),
                            arg_vals.len()
                        ),
                    ));
                }
                // 3b. Make the call
                function.call(self, arg_vals)
            }

            _ => Err(RuntimeError::new(
                paren.clone(),
                "Can only call functions and classes.".to_string(),
            )),
        }
    }
}

/*
memory safe means that through a combination of static and runtime checking, a program can never
incorrectly interpret the data stored in bits of memory

static and syntax errors are both errors that are detected and caught before any code is evaluated.
runtime errors are code that raises an error during evaluation

For example, this expression is valid:
    2 * (3 / -"muffin")
And we should report the runtime error in the inner expression when that inner expression is being
evaluated. Moreover, when an error is encountered, we should halt the evaluation process
but not exit the entire program.

The tree-walk interpreter evaluates the AST using recursive calls.
*/

impl StmtVisitor<Result<(), RuntimeError>> for Evaluator {
    fn visit_expression_stmt(&mut self, stmt: &Stmt) -> Result<(), RuntimeError> {
        if let Stmt::Expression { expression } = stmt {
            let _ = self.evaluate(expression)?;
        }
        Ok(())
    }

    fn visit_print_stmt(&mut self, stmt: &Stmt) -> Result<(), RuntimeError> {
        if let Stmt::Print { expression } = stmt {
            match self.evaluate(expression) {
                Ok(value) => {
                    println!("{}", value);
                    Ok(())
                }
                Err(err) => Err(err),
            }
        } else {
            Ok(())
        }
    }

    fn visit_var_stmt(&mut self, stmt: &Stmt) -> Result<(), RuntimeError> {
        if let Stmt::Var { name, initializer} = stmt {
            let value = if let Some(expr) = initializer {
                Some(self.evaluate(expr)?)
            } else {
                Some(Value::Nil)
            };

            self.environment.define(name.lexeme.clone(), value.unwrap());
            Ok(())
        } else {
            unreachable!("Expected Var statement in visit_var_stmt")
        }
    }

    fn visit_block_stmt(&mut self, statements: &Vec<Stmt>) -> Result<(), RuntimeError> {
        let child_env = Environment::new_enclosed(self.environment.clone());
        self.execute_block(statements, child_env)
    }

    // the part which makes control flow special is the if statement. All other expressions
    // evaluate their subexpressions by recursion or by calling some other method.
    fn visit_if_stmt(&mut self, condition: &Expr, then_branch: &Stmt, else_branch: &Option<Box<Stmt>>) -> Result<(), RuntimeError> {
        let cond_val = self.evaluate(condition)?;

        if self.is_truthy(&cond_val) {
            self.execute(then_branch)?;
        } else if let Some(else_stmt) = else_branch {
            self.execute(else_stmt)?;
        }

        Ok(())
    }

    fn visit_while_stmt(&mut self, condition: &Expr, body: &Stmt) -> Result<(), RuntimeError> {
        while {
            let cond_val = self.evaluate(condition)?;
            self.is_truthy(&cond_val)
        } {
            self.execute(body)?;
        }
        Ok(())
    }

    fn visit_fun_stmt(&mut self, name: &Token, params: &Vec<Token>, body: &Vec<Stmt>) -> Result<(), RuntimeError> {
        /*
        This is similar to how we interpret other literal expressions. We take a function
        syntax node, a compile-time representation of the function - and convert it to a runtime
        representation of the code. HEre, that's a LoxFunction that wraps the syntax node.
        
        Function declarations are different from other literal nodes in that the
        declaration also binds the resulting object to a new variable. So, after creating the
        LoxFunction, we create a new binding in the current environment and
        store a reference to it there.
        */
        let func_decl = Stmt::Function {
            name: name.clone(),
            params: params.clone(),
            body: body.clone(),
        };


        let closure: Rc<Environment> = Rc::from(self.environment.clone());

        // wrap it into a callable object
        let function_obj = Value::Callable(Rc::new(LoxFunction::new(func_decl, closure)));

        // define the variable in the *current* environment
        self.environment.define(name.lexeme.clone(), function_obj);


        Ok(())
    }

    fn visit_return_stmt(&mut self, _keyword: &Token, value: &Option<Box<Expr>>) -> Result<(), RuntimeError> {
        let result = if let Some(expr) = value {
            Some(self.evaluate(expr)?)
        } else {
            None
        };

        // Propagate the return using a special error or control signal
        Err(RuntimeError::Return(result))
    }
}

#[derive(Debug)]
pub enum RuntimeError {
    Error {
        token: Token,
        message: String,
    },
    Return(Option<Value>),
}

impl RuntimeError {
    pub fn new(token: Token, message: String) -> Self {
        RuntimeError::Error { token, message }
    }
}

use std::fmt::{Display};

impl Display for RuntimeError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            RuntimeError::Error { token, message } => {
                write!(
                    f,
                    "[line {}] RuntimeError at '{}': {}",
                    token.line, token.lexeme, message
                )
            }
            RuntimeError::Return(_) => write!(f, "<return control flow>"),
        }
    }
}

impl std::error::Error for RuntimeError {}


impl Evaluator {
    pub fn new(environment: Environment) -> Self {
        Self {
            environment
        }
    }

    pub fn evaluate(&mut self, expr: &Expr) -> Result<Value, RuntimeError> {
        expr.accept(self)
    }

    pub fn execute(&mut self, stmt: &Stmt) -> Result<(), RuntimeError> {
        stmt.accept(self)
    }

    /*
    Manually changing and restoring a mutable environment field feels inelegant. Another
    classic approach is to explicitly pass the environment as a parameter to each visit method.
    To `change` the environment, you pass a different one as you recurse down the tree.
    
    You don't have to restore the old environment since it lives in the Java stack environment.
    */
    pub(crate) fn execute_block(
        &mut self,
        statements: &[Stmt],
        new_env: Environment,
    ) -> Result<(), RuntimeError> {
        // Swap current and new environments.
        // `old_env` now owns the previous scope, so we can restore it later.
        let old_env = std::mem::replace(&mut self.environment, new_env);

        // Ensure the previous environment is restored even on early return or error.
        let result = (|| {
            for stmt in statements {
                self.execute(stmt)?;
            }
            Ok(())
        })();

        // put the original environment back
        self.environment = old_env;
        result
    }

    pub fn check_number_operand(
        &self,
        operator: Token,
        operand: &Value,
    ) -> Result<(), RuntimeError> {
        // this mechanism keeps track of the token which causes the runtime error
        // so we can print the token and line that triggered the runtime error
        match operand {
            Value::Number(_) => Ok(()),
            _ => Err(RuntimeError::new(
                operator,
                "Operand must be a number".parse().unwrap(),
            )),
        }
    }

    pub fn check_number_operands(
        &self,
        operator: Token,
        left: &Value,
        right: &Value,
    ) -> Result<(), RuntimeError> {
        // this mechanism keeps track of the token which causes the runtime error
        // so we can print the token and line that triggered the runtime error
        match left {
            Value::Number(_) => match right {
                Value::Number(_) => Ok(()),
                _ => Err(RuntimeError::new(
                    operator,
                    "Right operand must be a number".parse().unwrap(),
                )),
            },
            _ => Err(RuntimeError::new(
                operator,
                "Left operand must be a number".parse().unwrap(),
            )),
        }
    }

    pub fn is_truthy(&self, value: &Value) -> bool {
        match value {
            Value::Nil => false,
            Value::Bool(b) => *b,
            _ => true,
        }
    }

    pub fn is_equal(&self, v1: &Value, v2: &Value) -> bool {
        match (v1, v2) {
            (Value::Nil, Value::Nil) => true,
            (Value::Bool(b1), Value::Bool(b2)) => b1 == b2,
            (Value::Number(n1), Value::Number(n2)) => n1 == n2,
            (Value::String(s1), Value::String(s2)) => s1 == s2,
            _ => false,
        }
    }
}
